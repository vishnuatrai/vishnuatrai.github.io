<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MongoDB&nbsp;4.0 | @vishnuatrai]]></title>
  <link href="http://vishnuatrai.in/blog/categories/mongodb-4-dot-0/atom.xml" rel="self"/>
  <link href="http://vishnuatrai.in/"/>
  <updated>2020-05-17T21:14:49+05:30</updated>
  <id>http://vishnuatrai.in/</id>
  <author>
    <name><![CDATA[vishnuatrai.in]]></name>
    <email><![CDATA[vishnu.atrai@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MongoDB 4.0 - Support for ACID Transactions]]></title>
    <link href="http://vishnuatrai.in/blog/2018/12/20/mongodb-4-dot-0-support-for-acid-transactions/"/>
    <updated>2018-12-20T17:41:34+05:30</updated>
    <id>http://vishnuatrai.in/blog/2018/12/20/mongodb-4-dot-0-support-for-acid-transactions</id>
    <content type="html"><![CDATA[<h3>Support for Single-Shard multi document ACID transactions</h3>

<p>To support benefits of ACID transactions with fully-denormalized document data modeling, MongoDB added single-shard ACID transaction support in the released 4.0. These single-shard transactions apply ACID properties on updates across multiple documents those are present in the same shard. Multi-shard transactions supposed to implement in release 4.2.</p>

<h4>Scenario, how it works?</h4>

<ol>
<li>Client application will get a database session <!--more--></li>
<li><p>Database session initiate transaction block using <code>start_transaction</code> statement with <code>majority</code> <code>writeConcern</code> in <code>try</code> block. The only <code>writeConcern</code> thats suitable for high data durability is that of majority. This means a majority of replicas should commit the changes before the primary acknowledges the success of the write to the client. The transaction will remain blocked till at least 1 of the 2 secondaries pulls the update from the primary using asynchronous replication which is susceptible to unpredictable replication lag especially under heavy load.</p></li>
<li><p>Within transaction block multiple insert/update/remove statements can be made.</p></li>
<li>At end of transaction block <code>commit_transaction</code> required to commit data in database.</li>
<li>If any exception occurs in transaction block, client application should <code>abort_transaction</code> in <code>catch</code> block to roll back updates.</li>
<li>Finally the database client session can be closed in <code>finally</code> block</li>
</ol>


<p>Sample Java code to mimic same scenario,</p>

<pre><code>###Java sample
private void multiDocumentTransactions() {
    ClientSession session = client.startSession();
    try {
        session.startTransaction(TransactionOptions.builder().writeConcern(WriteConcern.MAJORITY).build());
        orders.updateOne(session, {..filter..}, {..updates..});
        stock.updateOne(session, {..filter..}, {..updates..});
        session.commitTransaction();
    } catch (MongoCommandException e) {
        session.abortTransaction();
        //ROLLBACK TRANSACTION
    } finally {
        session.close();
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
