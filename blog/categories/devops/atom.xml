<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: DevOps | @vishnuatrai]]></title>
  <link href="http://vishnuatrai.in/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://vishnuatrai.in/"/>
  <updated>2019-12-27T20:34:05+05:30</updated>
  <id>http://vishnuatrai.in/</id>
  <author>
    <name><![CDATA[vishnuatrai.in]]></name>
    <email><![CDATA[vishnu.atrai@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dive Into Docker Image Layers]]></title>
    <link href="http://vishnuatrai.in/blog/2019/12/26/dive-into-docker-image-layers/"/>
    <updated>2019-12-26T20:48:58+05:30</updated>
    <id>http://vishnuatrai.in/blog/2019/12/26/dive-into-docker-image-layers</id>
    <content type="html"><![CDATA[<p>I recently used a tool named <a href="https://github.com/wagoodman/dive"><code>dive</code></a> to explore docker images developed and maintained by teammates or opensourced docker images. I used to look into <code>Dockerfile</code> steps to explore image layes. <code>dive</code> brings cli-ui and using arrow and tab keys we can explore each layer in left pane while layer contents listed in right pane.<!--more--></p>

<p>Essentially <code>dive</code> based on docker api and its cache contents and provides commands to explore layer contents and minimize the size of images.</p>

<p>Installation</p>

<p><code>brew install dive</code></p>

<p>command to explore a image layers</p>

<p><code>dive &lt;docker-image-id&gt;</code></p>

<p>to build a image using <code>dive</code> command</p>

<p><code>dive build -t &lt;image-tag&gt; .</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins Slave With Docker Executors]]></title>
    <link href="http://vishnuatrai.in/blog/2019/08/08/jenkins-slave-with-docker-executors/"/>
    <updated>2019-08-08T16:35:25+05:30</updated>
    <id>http://vishnuatrai.in/blog/2019/08/08/jenkins-slave-with-docker-executors</id>
    <content type="html"><![CDATA[<p><a href="https://wiki.jenkins.io/display/JENKINS/Docker+Plugin">Docker Plugin</a> enables jenkins to run jobs as docker container. In such case we dont need to setup jenkins nodes(agents) with specific binaries, instead docker images will be used to run jobs.<!--more-->Jenkins master needs to be configured with docker host where we can push docker images, those will be used by agents to execute jobs.</p>

<h3>Global Configuration</h3>

<p>After installation of <code>Docker Plugin</code> from manage plugins options, we will need to configure docker host and templates to create docker executers in Global Configuration option.</p>

<p>Go to <strong>Global Configurations</strong> &ndash;> <strong>Docker</strong> &ndash;> fill the below configuration options to setup docker host <br />
<strong>Name</strong>    Name of docker slave to be used in job configuration  <br />
<strong>Docker Url</strong>    docker engine url and port  <br />
<strong>Docker Template</strong>    docker template is an executor, we can add multiple templates and it will enable multiple executors  <br />
Fill below configurations to setup docker template <br /></p>

<ul>
<li><strong>Docker Image</strong> image name that that is available on docker host and having binaries to run the job</li>
<li><strong>Container Settings</strong> > <strong>Volumes</strong> Provide the container volumes(ie. <code>/home/dockerslave/bin</code>) where the binaries available, these are mapped with host machine and binaries will be available on host machine to run the job.</li>
<li><strong>Label</strong> Provide the label to uniquely identify the executor and configure in job configuration</li>
<li><strong>Launch Method</strong> select <strong>Docker ssh compute launcher</strong></li>
<li><strong>Credentials</strong> select credential id to ssh into docker host container</li>
</ul>


<h3>Job Configuration</h3>

<p><strong>Build</strong> > check <strong>Restrict where this project can be run</strong> > <strong>Label Expression</strong> > provide the docker template lable</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins - Add Slave Nodes as JNLP Agents]]></title>
    <link href="http://vishnuatrai.in/blog/2019/04/15/jenkins-add-slave-nodes-as-jnlp-agents/"/>
    <updated>2019-04-15T15:36:54+05:30</updated>
    <id>http://vishnuatrai.in/blog/2019/04/15/jenkins-add-slave-nodes-as-jnlp-agents</id>
    <content type="html"><![CDATA[<p>If it is required to run Jenkins master in an isolated network and master should not be allowed to connected to its nodes(agents), we can use JNLP method to add agents to master to process jobs in distributed manner. In this scenario, its not desirable to have master connections with slave(agent) nodes but agent to master connections only required. <!--more--></p>

<h3>Only Agent to master connections</h3>

<p>In this case the agent node will not be visible to the master, so the master can not initiate the agent process. You can use a different type of agent configuration in this case called &ldquo;JNLP&rdquo;. This means that the master does not need network &ldquo;ingress&rdquo; to the agent (but the agent will need to be able to connect back to the master). Handy for if the agents are behind a firewall, or perhaps in some more secure environment to do trusted deploys.</p>

<h3>Configuration</h3>

<p>In order to setup a slave agent in above scenario you need to first <strong>Enable the JNLP Agents</strong>:</p>

<p>Go to <strong>Manage Jenkins</strong> &ndash;> <strong>Configure Global Security</strong> &ndash;> under <strong>Agents</strong> section &ndash;> <strong>TCP port for inbound agents</strong> &ndash;> select <strong>Random</strong> &ndash;><strong>Save</strong>.</p>

<h4>Setup slave agent node</h4>

<p>Go to <strong>Manage Jenkins</strong> &ndash;> <strong>Manage Nodes</strong> &ndash;>click on <strong>New Node</strong> &ndash;> Enter the <strong>node name</strong> &ndash;> Select <strong>permanent agent</strong>.</p>

<p>Fill the below details to configure the slave agent</p>

<h4>Description</h4>

<h4>Remote root directory</h4>

<p>This should be the workspace directory on slave agent</p>

<h4>Label</h4>

<p>Provide the label to uniquely identify the slave node</p>

<h4>Launch Method</h4>

<p>Select <strong>launch agent by Connecting it to the master</strong> for windows agents  <br />
and <strong>launch agents via ssh</strong> for linux agents</p>

<p>To Launch the slave agent via command line  <br />
<strong>Download the agent.jar file and copy to agent node</strong>  <br />
<strong>Run agent.jar using command line</strong></p>

<pre><code>java --jar agent.jar -jnlpUrl &lt;jenkins master url&gt; -secret &lt;secret given on node configuration&gt; -workDir "/user/agent/home/workspace"
</code></pre>

<p>With above command agent is authorized and registered with jenkins master. Now agent is successfully configured and launched, which can be verified on master nodes. Jenkins master can delegate jobs to agent node.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ProxySQL - MySQL High Availability Load Balancing]]></title>
    <link href="http://vishnuatrai.in/blog/2018/11/12/proxysql-mysql-high-availability-load-balancing/"/>
    <updated>2018-11-12T22:59:40+05:30</updated>
    <id>http://vishnuatrai.in/blog/2018/11/12/proxysql-mysql-high-availability-load-balancing</id>
    <content type="html"><![CDATA[<h3>What is ProxySQL?</h3>

<ul>
<li>Lightweight Proxy layer for MySQL</li>
<li>Its protocol aware that we put between application and database server</li>
<li>Improve database operations <!--more--></li>
<li>Understand and solve performance issues</li>
<li>A proxy layer to shield the database</li>
<li>Add high availability to database topology</li>
</ul>


<h3>Why ProxySQL/HAProxy?</h3>

<p>ProxySQL provides below advantages if included in deployment stack</p>

<ul>
<li>Scalability

<ul>
<li>Connection Pooling and multiplexing</li>
<li>Read/Write split</li>
<li>Read/Write sharding</li>
</ul>
</li>
<li>High Availability

<ul>
<li>Seamless failover</li>
<li>Load balancing</li>
<li>Cluster aware</li>
</ul>
</li>
<li>Advance query and support

<ul>
<li>Query caching</li>
<li>Query rewrite</li>
<li>Query blocking</li>
<li>Query mirroring</li>
<li>Query throttling</li>
<li>Query timeout</li>
</ul>
</li>
<li>Manageability

<ul>
<li>Admin Utility</li>
<li>Runtime reconfiguration</li>
<li>Monitoring</li>
</ul>
</li>
</ul>


<h3>ProxySQL Configurations Options</h3>

<pre><code>mysql_replication_hostgroups
mysql_servers
mysql_server_connect_log
mysql_server_ping_log
mysql_server_replication_lag_log
mysql_server_read_only_log
stats_mysql_connection_pool
stats_mysql_commands_counters
mysql_query_rules
stats_mysql_query_digest
</code></pre>

<h3>References</h3>

<p><a href="https://www.proxysql.com/">https://www.proxysql.com/</a></p>

<p>docker sandbox</p>

<p><a href="https://github.com/vishnuatrai/MySQLSandbox">https://github.com/vishnuatrai/MySQLSandbox</a></p>

<p>github</p>

<p><a href="https://github.com/sysown/proxysql">https://github.com/sysown/proxysql</a></p>
]]></content>
  </entry>
  
</feed>
