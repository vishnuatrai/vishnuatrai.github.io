<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: React.js | @vishnuatrai]]></title>
  <link href="http://vishnuatrai.in/blog/categories/react-dot-js/atom.xml" rel="self"/>
  <link href="http://vishnuatrai.in/"/>
  <updated>2020-09-18T22:52:29+05:30</updated>
  <id>http://vishnuatrai.in/</id>
  <author>
    <name><![CDATA[vishnuatrai.in]]></name>
    <email><![CDATA[vishnu.atrai@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React.js - HOCs vs Render Props vs Custom Hooks Patterns]]></title>
    <link href="http://vishnuatrai.in/blog/2020/02/02/react-dot-js-hocs-vs-render-props-vs-custom-hooks-patterns/"/>
    <updated>2020-02-02T11:57:42+05:30</updated>
    <id>http://vishnuatrai.in/blog/2020/02/02/react-dot-js-hocs-vs-render-props-vs-custom-hooks-patterns</id>
    <content type="html"><![CDATA[<p>Higher-Order Components(HOCs), Render Props and Custom Hooks are techniques to share common functionality between components. It&rsquo;s recommended to always go with hooks wherever possible. HOCs and render props patterns require you to restructure your components when you use them, which can be cumbersome and make code harder to follow.</p>

<h3>Higher-Order Components</h3>

<p>Higher-order component is a function that takes a component as an argument and returns a new component. HOC adds additional data and functionality to original component so new component also referred to as Enhanced component.<!--more--></p>

<pre><code>const NewComponent = higherOrderComponent(OriginalComponent)
const EnhancedComponent = higherOrderComponent(WrappedComponent)
</code></pre>

<p>Other possibilities with HOCs,<br />
1. Passing down the props using spread operator <br />
2. Passing parameters to higher order functions</p>

<pre><code>#example 
const withAdditionalFunctionality = (WrappedComponent, additionalArgs) =&gt; {
    class WithAdditionalFunctionality extends React.Component {
        constructor(props){
            super(props)
            this.state = { 
                state1: 'value1'
                ... 
            }
        }
        additionalFunctionality = () =&gt; { 
            //additionalArgs can be use here 
            ... 
        }
        render(){
            return( &lt;WrappedComponent
                        state1={this.state.state1} 
                        additionalFunctionality={this.additionalFunctionality} 
                        {...this.props} 
                    /&gt; )
        }
    }
    return WithAdditionalFunctionality;
}
export default withAdditionalFunctionality;
</code></pre>

<h3>Render Props Pattern</h3>

<p>Render Props is another pattern for sharing code between React components using a prop whose value is a function.</p>

<pre><code>class RenderProps extends React.Component {
        constructor(props){
            super(props)
            this.state = { 
                state1: 'value1'
                ... 
            }
        }
        additionalFunctionality = () =&gt; { 
            //props.additionalArgs
            ... 
        }
        render(){
            return(&lt;div&gt;
                    { this.props.render( state1={this.state.state1}
                        additionalFunctionality={this.additionalFunctionality} ) }
                &lt;/div&gt;)
        }
    }
    export default RenderProps;
    #Usage
    &lt;RenderProps 
        render={ (state1, additionalFunctionality) =&gt; { return &lt;div&gt; .... &lt;/div&gt; } } 
    /&gt;
    &lt;RenderProps 
        render={ (state1, additionalFunctionality) =&gt; { return &lt;p&gt; .... &lt;/p&gt; } } 
    /&gt;
</code></pre>

<h3>Custom Hooks</h3>

<p>Simpler alternative to HOCs and Render Props to share the common logic between components. A custom hook can also call other hooks if required. With Hooks, you can extract stateful logic from a component so it can be tested independently and reused. Hooks allow you to reuse stateful logic without changing your component hierarchy.</p>

<pre><code>import {useState} from 'react'
function useCustomHook(arguments){
    const [state1, setState1] = useState(arguments.initialState)
    const additionalFunctionality = () =&gt; {
       //arguments can be used here
       .....
    }
    ....
    return [state1, additionalFunctionality];
}
export default useCustomHook;
#Usage
function ConsumerComponent {
    const [state1, additionalFunctionality] = useCustomHook(initialValues and args...)
    render(
        &lt;div&gt;
            ....
        &lt;/div&gt;
    )
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React.js - Ways to Bind Events]]></title>
    <link href="http://vishnuatrai.in/blog/2019/10/12/react-dot-js-ways-to-bind-events/"/>
    <updated>2019-10-12T11:47:20+05:30</updated>
    <id>http://vishnuatrai.in/blog/2019/10/12/react-dot-js-ways-to-bind-events</id>
    <content type="html"><![CDATA[<h3>Background</h3>

<p>Event binding in ReactJs components required because of <code>this</code> keyword works in JavaScript, within click handler function <code>this</code> keyword will lost its context (component instance) or value.</p>

<h3>1. <code>bind</code> the handler in JSX render<!--more--></h3>

<pre><code>class BindHandler extends React.Component {
        constructor(props){
            ...
        }
        handlerFunction() { 
            console.log(this)
        }
        render(){
            return(&lt;button onClick={this.handlerFunction.bind(this)}&gt;Click Event&lt;/button&gt;)
        }
    }
</code></pre>

<h3>2. Arrow function in JSX render callback(<code>this</code> is bound lexically)</h3>

<pre><code>class ArrowFunctionBinding extends React.Component {
        constructor(props){
            ...
        }
        handlerFunction() { 
            console.log(this)
        }
        render(){
            return(&lt;button onClick={() =&gt; this.handlerFunction()}&gt;Click Event&lt;/button&gt;)
        }
    }
</code></pre>

<h3>3. <code>bind</code> in <code>constructor()</code></h3>

<pre><code>class ConstructorBinding extends React.Component {
        constructor(props){
            ...
            this.handlerFunction = this.handlerFunction.bind(this)
        }
        handlerFunction() { 
            console.log(this)
        }
        render(){
            return(&lt;button onClick={this.handlerFunction}&gt;Click Event&lt;/button&gt;)
        }
    }
</code></pre>

<h3>4. Define handler function as class property using Arrow function</h3>

<pre><code>class EventHandlerClassProperty extends React.Component {
        constructor(props){
            ...
            this.handlerFunction = this.handlerFunction.bind(this)
        }
        handlerFunction = () =&gt; { 
            console.log(this)
        }
        render(){
            return(&lt;button onClick={this.handlerFunction}&gt;Click Event&lt;/button&gt;)
        }
    }
</code></pre>

<h3>Recommendations</h3>

<p>React documentation suggests binding events in constructor. But if need to use <strong>arrow function in JSX render callback</strong> for its simplicity or when need to pass arguments, we should consider caching the handlers if the bindings become a performance issue.</p>
]]></content>
  </entry>
  
</feed>
